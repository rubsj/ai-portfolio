# Learning Notes — February 2026

### 2026-02-07 — Python Primer: Core Patterns for AI Development

**Session focus**: Completed python_primer.py — 6 sections covering Python fundamentals mapped to Java/TS equivalents.

---

### Type Hints (Section 1)
- **What**: Python type hints (`str`, `list[str]`, `dict[str, int]`, `str | None`) are syntactically similar to TS but NOT enforced at runtime.
- **Why it matters**: Pydantic enforces them at runtime — this is the safety net for LLM output validation.
- **Python pattern**: `def func(name: str, age: int) -> str:` — types go AFTER param name, return type uses `->`.
- **Java/TS equivalent**: Java puts type before param (`String name`), TS uses colon like Python but with lowercase types (`name: string`).

### F-Strings & Triple Quotes (Section 2)
- **What**: `f"..."` is Python's template literal. Triple-quoted `f"""..."""` preserves newlines — essential for multi-line LLM prompts.
- **Why it matters**: Every LLM prompt in generator.py will be a triple-quoted f-string.
- **Python pattern**: Use `{{ }}` to produce literal `{` `}` in f-strings (critical when embedding JSON examples in prompts).
- **Java/TS equivalent**: TS template literals `` `${var}` ``. No direct equivalent for the `{{ }}` escaping — TS doesn't have this conflict.

### Comprehensions (Section 3)
- **What**: `[x for x in items if condition]` replaces Java streams and TS `.filter().map()` chains.
- **Why it matters**: Idiomatic Python — reviewers will flag for-loops that could be comprehensions.
- **Python pattern**: Nested comprehensions read left-to-right in same order as nested for-loops: `[tool for r in records for tool in r["tools"]]` (outer loop first, inner loop second).
- **Java/TS equivalent**: Java `stream().flatMap().collect(toList())`, TS `items.flatMap(x => x.tools)`.
- **Key variants**: `[...]` = list, `{...}` = set (unique), `{k: v ...}` = dict.

### Pydantic v2 (Section 4)
- **What**: Runtime validation library. `BaseModel` = Bean Validation + Jackson combined. Validates types, constraints, and cross-field rules.
- **Why it matters**: THE safety net for LLM outputs. When GPT-4o-mini returns garbage JSON, Pydantic catches it.
- **Python patterns learned**:
  - `Field(min_length=1, description="...")` — constraints + JSON schema docs
  - `default_factory=list` NOT `default=[]` — mutable default gotcha
  - `@field_validator("field") @classmethod` — single-field validation (Pydantic v2 pattern)
  - `@model_validator(mode="after")` — cross-field validation (returns `self`)
  - `model_validate_json(json_string)` — parse + validate LLM response in one call
  - `model_json_schema()` — generates JSON schema to embed in LLM prompts
  - `Literal["a", "b", "c"]` over Enum for JSON/LLM work — cleaner serialization
- **Java/TS equivalent**: Bean Validation (`@NotNull`, `@Min`, `@Max`) + Jackson for Java. Zod for TS.

### Python Gotchas (Section 5)
- **What**: Python-specific footguns that Java/TS devs hit.
- **Key learnings**:
  - **Mutable defaults**: `def f(items=[])` shares one list across ALL calls. Fix: `items: list | None = None` then `if items is None: items = []`. In Pydantic: `default_factory=list`.
  - **`if __name__ == "__main__":`** — Python's entry point guard. Without it, importing a file executes all top-level code. Every project file needs this.
  - **Dict access**: `r["key"]` for dicts (bracket), `r.attr` for objects (dot). No mixing.
  - **`{**defaults, **overrides}`** — dict spread, like TS `{...defaults, ...overrides}`.
  - **`pathlib.Path`**: `Path("data") / "cache" / "file.json"` — uses `/` operator instead of `os.path.join`.
  - **`enumerate(items, start=1)`** — indexed iteration, like Java's indexed for-loop.

### Hashlib Caching (Section 6)
- **What**: `hashlib.md5(prompt.encode()).hexdigest()` generates deterministic cache keys from prompt strings.
- **Why it matters**: Cache LLM responses during development. Same prompt = same hash = skip the API call. Saves money and time.
- **Python pattern**: Check cache dict → if miss, call API and store → if hit, return cached response.
- **Java/TS equivalent**: Similar to using `Map.computeIfAbsent()` in Java with a hash key.

---

### Tools & Environment Setup
- **uv** installed at `~/.local/bin/uv` — added to PATH via `~/.zshrc`
- **Project structure**: `01-synthetic-data-home-diy/` has its own `pyproject.toml`, `.venv`, and CLAUDE.md
- Run with: `cd 01-synthetic-data-home-diy && uv run python <file>`

### Mistakes Made & Lessons
1. **`default_factory=[]` instead of `default_factory=list`** — passed the value instead of the callable (supplier). Think Java `Supplier<T>`.
2. **`r.tools` on a dict** — used dot notation instead of bracket notation. Rule: dict = brackets, object = dots.
3. **`id` as variable name** — shadows Python builtin `id()`. Use `key` or `first_letter` instead.
4. **Spaces before colons in type hints** — PEP 8 says no space before `:`. Ruff will flag this.
